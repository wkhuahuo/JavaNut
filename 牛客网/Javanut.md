#Java知识点锦集
##接口和抽象类的区别是什么？ 

###参考答案
> - Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>
	1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>
	- 类可以实现很多个接口，但是只能继承一个抽象类。<br>
	- 类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>
	- 抽象类可以在不提供接口方法实现的情况下实现接口。<br>
	- Java接口中声明的变量默认都是final的。<br>
	- 抽象类可以包含非final的变量。<br>
	- Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>
	- 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>
	- 也可以参考JDK8中抽象类和接口的区别<br>

##什么是值传递和引用传递？ 
###参考答案
> 1. 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 
- 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象. 
- 一般认为,java内的传递都是值传递. 

##线程与进程的区别归纳： 
###参考答案
>1. 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 
- 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 
- 调度和切换：线程上下文切换比进程上下文切换要快得多。 
d.在多线程OS中，进程不是一个可执行的实体。 

##创建线程有几种不同的方式？你喜欢哪一种？为什么？ 
###参考答案
>- 有三种方式可以用来创建线程：
	1. 继承Thread类
	- 实现Runnable接口
	- 应用程序可以使用Executor框架来创建线程池
- 实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。
-同时，线程池也是非常高效的，很容易实现和使用。

##概括的解释下线程的几种可用状态。 
###参考答案<br>
>1. 新建( new )：新创建了一个线程对象。 
2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。 
3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。 
4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<br> 
(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。 
(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。 
(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。????????????当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。 
5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。 
![threadstatus.png](threadstatus.png)
<br>


##在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 
###参考答案
> 监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。
<br>

##多线程产生死锁的四个必要条件： 
> 1. 互斥条件：一个资源每次只能被一个进程使用。
- 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。 
- 不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺。 
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 

- 只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。

##Iterator和ListIterator的区别是什么？ 
###参考答案
>- Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
- Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
- ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

##Java中的HashMap的工作原理是什么？ 
###参考答案
>Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

##HashMap和Hashtable有什么区别？ 
###参考答案
>+ HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>
	1. HashMap允许键和值是null，而Hashtable不允许键或者值是null。
	- Hashtable是同步的，而HashMap不是。
	- HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
	- HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，	- Hashtable提供了对键的列举(Enumeration)。
+ 一般认为Hashtable是一个遗留的类。

##ArrayList和LinkedList有什么区别？ 
###参考答案
>+ ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
	1. ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。
	- LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
	- 相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
	- LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
+ 也可以参考ArrayList vs. LinkedList。

##Comparable和Comparator接口是干什么的？列出它们的区别。 
###参考答案
>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。

##什么是Java优先级队列(Priority Queue)？ 
###参考答案
> 1. PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。
- 在创建的时候，我们可以给它提供一个负责给元素排序的比较器。
- PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。
- PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。
- PriorityQueue本质上就是堆排序里面建的最小堆。最小堆满足的一个基本性质是堆顶端的元素是所有元素里最小的那个。如果我们将顶端的元素去掉之后，为了保持堆的性质，需要进行调整。对堆的操作和调整主要包含三个方面，增加新的元素，删除顶端元素和建堆时保证堆性质的操作。


##Java集合类框架的最佳实践有哪些？ 
###参考答案
>1. 根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。
- 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。
- 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。
- 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。
- 编程的时候接口优于实现。
- 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。

## HashSet和TreeSet有什么区别？ 
###参考答案
>+ HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
+ 另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。

##Java中垃圾回收有什么目的？什么时候进行垃圾回收？ 
###参考答案？？？
> ?

##System.gc()和Runtime.gc()会做什么事情？ 
###参考答案?
> 这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。

##finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 
###参考答案
>垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 

##Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 
###参考答案<×>
>1. JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
- 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。

##串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 
###参考答案
>- 吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。
- 行收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而吞吐量收集器则的目标是达到一个可控制的吞吐量。此外，吞吐量收集器具有自适应调节策略的能力。


##在Java中，对象什么时候可以被垃圾回收？ （如何判断一个对象可以被回收？Java的机制是什么？）
###参考答案
> ?

#JVM的永久代中会发生垃圾回收么？ 
###参考答案
>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)

##Java中Exception和Error有什么区别？ 
###参考答案
>Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。


##throw和throws有什么区别？
###参考答案
>1. Throw用于抛出异常对象，后面跟的时异常对象。是语句抛出一个异常。多用在函数内。 
语法：throw(异常对象) 
	`throw e;` 
2. Throws是方法可能抛出异常的声明（用在声明方法时，表示该方法可能要抛出异常） 
语法：修饰符 返回值类型 方法名 ?参数类型 ?throws异常类 
`public void test throws Exception1,Exception2(){}` 

##异常处理完成以后，Exception对象会发生什么变化？ 
###参考答案
>Exception对象会在下一个垃圾回收过程中被回收掉。

##final、finally代码块和finalize()方法有什么区别？
> 1. final是关键字，final可以修饰类、方法、属性。
	- 如果一个类被final修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是final类中的成员变量是可以改变的，要想final类中的成员变量的不可以改变，必须给成员变量添加final修饰。因此，一个类不能同时被final和abstract修饰，这两个关键字相互矛盾。
  - 如果final修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：final参数用来表示这个参数在这个函数内部不允许被修改。
  - final修饰属性，被final修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。final指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被final修饰的变量必须初始化，该变量其实就是常量。
2. finally作为异常处理的一部分，只能用在try/catch语句快中，finally代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。
3. finalize是Object类的一个方法，该方法在Object类中声明：`
        protected void finalize() throws Throwable { } `
    在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的
finalize()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。


##解释一下Applet的生命周期 
###参考答案
>applet可以经历下面的状态：
Init：每次被载入的时候都会被初始化。
Start：开始执行applet。
Stop：结束执行applet。
Destroy：卸载applet之前，做最后的清理工作。

##当applet被载入的时候会发生什么？ 
##参考答案
>首先，创建applet控制类的实例，然后初始化applet，最后开始运行。



##Applet和普通的Java应用程序有什么区别？ 
###参考答案
》applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。
进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。
最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。